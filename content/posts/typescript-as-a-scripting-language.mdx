---
title: TypeScript is a scripting language
description: "A skeptic's take on why Bun, and therefore TypeScript, is the future of scripting"
author: Caulk
date: "2025-12-22T14:46:50-05:00"
draft: false
tags: [typescript, bun, scripting]
---

I needed a quick way to upload benchmark tasks to a remote server and run them in tmux sessions I could monitor. I just wanted a quick, single command way to sync files, spin up a background process, and stream logs back - all without blocking my terminal or losing output when I disconnect. It has to play well with my agents.

As some of you may already know, Bun makes this stupidly easy.

## The Problem

I'm working on a custom benchmark suite that runs containerized tasks. The workflow is:

1. Edit task locally
2. Run the task locally (often blocking my own compute)
3. Run the benchmark runner (which orchestrates docker containers, asciinema, tmux, etc.)
4. Monitor output
5. Iterate

I'm usually working on >1 tasks at a time, so again, compute gets tied up.

So I started uploading to my servers, but doing this manually means a lot of `scp`, `ssh`, `tmux attach`, copy-pasting commands. 

Tedious. 

Let me get back to work.

Now I'm certain there's an easier way to do this. But I'm too lazy to setup a file syncing service as my boxes change often. So, I reached for Bun after initially considering Python.

## Bun's Shell API

The buntime [shell API](https://bun.com/docs/runtime/shell) feels like writing bash, but with TypeScript's type safety and async/await. Here's the core of the upload function:
```typescript
import { $ } from "bun";

async function uploadTask(localPath: string, taskId: string) {
  await $`ssh ${REMOTE_HOST} mkdir -p ${REMOTE_DIR}`.quiet();
  await $`ssh ${REMOTE_HOST} rm -rf ${remotePath}`.quiet();
  await $`scp -r ${localPath} ${REMOTE_HOST}:${remotePath}`.quiet();
}
```
That's it. No child_process spawning, no callback hell, no shell escaping nightmares. The template literal syntax handles interpolation safely, and `.quiet()` suppresses stdout when you don't need it.

## Tmux Orchestration

The interesting part is managing remote tmux sessions. I generate a bash script, write it to the remote, then execute it in a detached tmux session:
```typescript
const script = `#!/bin/bash
source ~/.local/bin/env
cd ~/workspace
echo "[runner] starting at $(date)"
sg docker -c "runner --path ${taskPath} --debug"
EXIT_CODE=$?
echo "[runner] finished with exit code $EXIT_CODE"
exec bash
`;
await $`ssh ${HOST} "cat > /tmp/run-${taskId}.sh << 'SCRIPT'\n${script}\nSCRIPT"`;
await $`ssh ${HOST} chmod +x /tmp/run-${taskId}.sh`;
await $`ssh ${HOST} tmux new-session -d -s ${sessionName} /tmp/run-${taskId}.sh`;
```
The `exec bash` at the end keeps the session alive after the task completes - useful for debugging failures. The `sg docker -c` trick runs the command with docker group permissions without requiring a full logout/login after adding a user to the group.

## Streaming Logs

Polling tmux's capture-pane gives you a poor man's log stream:
```typescript
async function streamSession(sessionName: string) {
  let lastLineCount = 0;
  
  const poll = async () => {
    const logs = await $`ssh ${HOST} tmux capture-pane -t ${sessionName}:0 -S -1000 -p`.text();
    const lines = logs.split("\n");
    
    if (lines.length > lastLineCount) {
      lines.slice(lastLineCount).forEach(line => console.log(line));
      lastLineCount = lines.length;
    }
  };
  
  setInterval(poll, 500);
}
```
Not as elegant as a proper websocket stream, but it works and took 30 seconds to ~~write~~prompt.

## The CLI

Bun's `parseArgs` from `util` handles the argument parsing:
```typescript
const { values, positionals } = parseArgs({
  args: Bun.argv.slice(2),
  options: {
    path: { type: "string", short: "p" },
    logs: { type: "boolean", short: "l" },
    stream: { type: "boolean", short: "s" },
    kill: { type: "boolean", short: "k" },
  },
  allowPositionals: true,
});
```
Final usage looks like:

```bash
# upload and run
./snorkel-helper oracle -p tasks/my-benchmark

# stream logs
./snorkel-helper oracle -p tasks/my-benchmark --stream

# kill session
./snorkel-helper oracle -p tasks/my-benchmark --kill
```

## Caveats

**This is duct tape, not infrastructure.** For real CI/CD you'd use ~~GitHub Actions~~[Forgejo Actions](https://docs.codeberg.org/ci/actions/), [Buildkite](https://buildkite.com/), or whatever your org already has. But when you need something working in under 10 minutes, Bun's shell API is hard to beat.

**SSH multiplexing helps.** If you're making many SSH calls, add this to your `~/.ssh/config`:
```
Host your-server
  ControlMaster auto
  ControlPath ~/.ssh/sockets/%r@%h-%p
  ControlPersist 600
```
**Error handling is minimal.** The script assumes SSH works, the remote has tmux, Docker is configured, etc. Production code would need actual error handling.

**Tmux capture-pane has limits.** The scrollback buffer is finite. For long-running tasks, you'd want to pipe output to a file and tail that instead.

## Why Bun?

I could've written this in bash. But:

- Bun's shell escaping is safer than string concatenation in bash
- Async/await makes sequential operations readable
- TypeScript catches typos before runtime
- Single file, no build step, runs directly with `bun run script.ts`

The whole thing is ~200 lines and took maybe 15 minutes including debugging SSH/tmux quoting issues. Most of that time was figuring out that the benchmark runner expected a specific directory structure - nothing to do with Bun.

For quick automation scripts that shell out a lot, Bun hits a sweet spot between "bash script that grows out of control" and "proper application that needs a build system."
